/*
 * generated by Xtext 2.17.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import LegalSC.Contrat
import LegalSC.Entete
import LegalSC.ClauseSection
import LegalSC.Clause
import LegalSC.Variable
import LegalSC.Partie
import LegalSC.Execution
import LegalSC.Droit
import LegalSC.Executable
import LegalSC.SiAlors
import LegalSC.Expression
import LegalSC.Condition
import LegalSC.ActiveDesactive
import LegalSC.DateChange
import LegalSC.NumChange

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator extends AbstractGenerator {
		

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		PdfGenerator.pdfGenerate(resource, fsa);
		val c = resource.allContents.toIterable.filter(Contrat).get(0)
		fsa.generateFile(
			c.nom + ".sol",
			c.compile)
	}
	
	def compile(Contrat c) '''
		«»
		pragma solidity >= 0.5.0 < 0.6.0;
		import "./DateTime.sol";
		
		contrat «c.nom» {
			«c.entete.compile»
			
			«generateValidators()»
			
			«compileConstructor(c.entete)»
		
			«FOR s : c.clausesection»
				«s.compile»
			«ENDFOR»
		}
	'''
	
	def compileConstructor(Entete e) '''
		constructor(string memory _pdfHash) public {
			pdfHash = _pdfHash;
		«FOR v : e.variable»
			«IF v.type=="date"»
				«v.nom» = new DateTime();
				«IF v.date !== null »
				«v.nom».toTimestamp(«Integer.parseInt(v.date.toString().split("/").get(2))», «Integer.parseInt(v.date.toString().split("/").get(1))», «Integer.parseInt(v.date.toString().split("/").get(0))»);
				 «ENDIF»
			«ENDIF»
		«ENDFOR»
		}
	'''
	
	
	def compile(Entete e) '''
		bool private active = true;
		string private pdfHash ;
		uint private date_debut = «e.date_debut» ;
		«FOR p : e.partie»
			«p.compile»
		«ENDFOR»
		«FOR v : e.variable»
			«v.compile»
		«ENDFOR»
	'''
	
	def compile(Partie p)'''
		address private «p.role» = «p.adresse» ;
	'''
	
	def compile(Variable v) '''
		«IF v.type==='date'»
			DateTime private «v.nom» ;
		«ENDIF»
		«IF v.type==='nombre'»
			uint private «v.nom» = «v.nombre» ;
		«ENDIF»
		«IF v.type==='adresse'»
			address private «v.nom» «IF v.adresse!==null»= «v.adresse» «ENDIF»;
		«ENDIF»
	'''
	
	def compile(ClauseSection s) '''
		«FOR c : s.clause»
			«c.compile»
		«ENDFOR»
	'''
	
	def compile(Clause c) '''
		bool active_«c.nom» = true ;
		«c.execution.compile(c.nom)»
	'''
	
	def compile(Execution e, String name) '''
		«e.droit.precompile(name, e.operateurLogique)»
		function «name»() public «e.droit.compile(name, e.operateurLogique)» isActive{
			require(active_«name») ;
			«FOR exec : e.executable»
				«exec.compile»
			«ENDFOR»
		}
	'''
	
	def compile(Executable e) '''
		«IF e instanceof SiAlors»
			«(e.compileSiAlors)»
		«ENDIF»
		«IF e instanceof Expression»
			«e.compileExpression»
		«ENDIF»	
	'''
	
	def compileSiAlors(SiAlors sa) '''
		«»
		if («sa.condition.compile») {
			«FOR e : sa.executable»
			«e.compile»
			«ENDFOR»
		}
	'''
	
	def compile(Condition c) '''
		«c.condition».passed()
	'''
	
	def compileExpression(Expression e) '''
		«IF e instanceof ActiveDesactive»
			«(e.compileActiveDesactive)»
		«ENDIF»
		«IF e instanceof DateChange»
			«e.compileDateChange»
		«ENDIF»	
		«IF e instanceof NumChange»
			«e.compileNumChange»
		«ENDIF»	
	'''
	
	def compileActiveDesactive(ActiveDesactive ad)'''
		«IF ad.action=="active"»
			active_«ad.nom_clause_ou_contract» = true;
		«ELSE»
			active_«ad.nom_clause_ou_contract» = false;
		«ENDIF»
	'''
	
	def compileDateChange(DateChange dc)'''
		«IF dc.date_base===null»
			«dc.var_a_change» = «dc.date_base»;
		«ELSE»
			«dc.var_a_change».parseTimestamp(now);
		«ENDIF»
		
		«dc.var_a_change».addDays(«dc.decalage»);
	'''
	
	def compileNumChange(NumChange nc)'''
		«nc.var_a_change» += «nc.decalage»;
	'''
	
	def precompile(Droit[] d, String name, String operator)'''
		address «name»_rule = [«d.get(0).parties» «FOR p : d.subList(1,d.size())», «p.parties»«ENDFOR»];
		
		«IF operator==='et'»
			mapping(address => bool) public «name»_state;
		«ENDIF»
	'''
	
	def compile(Droit[] d, String name, String operator)'''
		«IF operator==='et'»
			andValidator(«name», «name»_rule)
		«ELSE»
			orValidator(«name»_rule)
		«ENDIF»
	'''
	
	def generateValidators() '''
		modifier isActive {
					require(active);
					_;
				}
				
				modifier isInactive {
					require(!active);
					_;
				}
				modifier orValidator(address[] storage parties) {
					for(uint i = 0; i < parties.length; ++i) {
						if(msg.sender == parties[i]) {
							_;
							return;
						}
					}
					revert();
				}
				modifier andValidator(mapping(address => bool) storage _registre, address[] storage parties) {
					for(uint i = 0; i < parties.length; ++i) {
						if(msg.sender == parties[i]) {
							_registre[parties[i]] = true;
							break;
						}
					}
				
					for(uint i = 0; i < parties.length; ++i) {
						if(_registre[parties[i]] == false) {
							return;
						}
					}
				
					for(uint i = 0; i < parties.length; ++i) {
						_registre[parties[i]] = false;
					} 
				
					_;
				}
	'''
}
